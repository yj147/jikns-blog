### **现代化博客与社交动态平台 - 架构设计文档**

**版本**: 4.1 (Aligned with implementation) **日期**: 2025年8月21日 **编制**:
Gemini AI

---

### **1.0 项目愿景与核心原则**

#### **1.1 项目愿景**

为个人创作者打造一个集**专业内容发布**与**社区互动**于一体的现代化全栈平台。平台包含两大核心：一个由单一管理员控制的、高质量的**博客系统**；以及一个所有注册用户均可参与的、充满活力的**社交动态系统**。

#### **1.2 核心设计原则**

1.  **双重核心 (Dual
    Core)**: 明确区分**管理员博客管理**和**多用户社区互动**两套业务逻辑和权限体系。
2.  **灵活认证 (Flexible Authentication)**: 同时支持 OAuth
    (GitHub) 和 传统邮箱/密码两种认证方式。
3.  **精细化授权 (Granular Authorization)**: 通过**角色 (Role)** 和
    **状态 (Status)** 对用户进行精细化的权限控制。
4.  **模型通用化 (Polymorphic
    Models)**: 对评论、点赞等跨模块功能，采用通用的数据模型。
5.  **BaaS 驱动 (BaaS
    Driven)**: 以 Supabase 为核心，处理数据库、认证、存储等服务。

---

### **2.0 技术栈选型**

| 类别                | 技术选型                    | 建议版本 (截至 2025-08)      |
| :------------------ | :-------------------------- | :--------------------------- |
| **运行时环境**      | **Node.js**                 | `~22.x` (LTS)                |
| **包管理器**        | **pnpm**                    | `~9.12.x`                    |
| **核心语言**        | **TypeScript**              | `~5.9.x`                     |
| **全栈框架**        | **Next.js**                 | `~15.5.x` (稳定版)           |
| **核心库**          | **React**                   | `~19.1.x`                    |
| **后端平台 (BaaS)** | **Supabase (JS Libraries)** | `@supabase/supabase-js@~2.x` |
| **本地开发**        | **Docker + Supabase CLI**   | `Docker Compose + ~1.226.x`  |
| **ORM**             | **Prisma**                  | `~6.14.x`                    |
| **UI 基础**         | **Tailwind CSS**            | `~4.1.x`                     |
| **UI 组件**         | **shadcn/ui + magic ui**    | (N/A)\*                      |
| **动画库**          | **Framer Motion**           | `~12.23.x`                   |
| **测试**            | **Vitest**                  | `~2.x`                       |
|                     | **React Testing Library**   | `~15.0.x`                    |

_\*注：shadcn/ui 和 magic
ui 通过 CLI 将组件源码直接复制到项目中，其版本体现在执行 CLI 命令时获取的最新代码。_

---

### **3.0 数据架构与模型 (Prisma Schema)**

**文件**: `prisma/schema.prisma`

```prisma
generator client {
  provider      = "prisma-client-js"
  output        = "../lib/generated/prisma"
  binaryTargets = ["native"]
  engineType    = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Activity {
  id            String                   @id @default(uuid())
  content       String
  isPinned      Boolean                  @default(false)
  createdAt     DateTime                 @default(now())
  updatedAt     DateTime                 @updatedAt
  authorId      String
  commentsCount Int                      @default(0)
  deletedAt     DateTime?
  likesCount    Int                      @default(0)
  viewsCount    Int                      @default(0)
  imageUrls     String[]                 @default([])
  contentTokens String?
  search_vector Unsupported("tsvector")? @default(dbgenerated("setweight(to_tsvector('simple'::regconfig, COALESCE(\"contentTokens\", ''::text)), 'A'::\"char\")"))
  author        User                     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tagCandidates ActivityTagCandidate[]
  tags          ActivityTag[]
  comments      Comment[]
  likes         Like[]
  notifications Notification[]

  @@index([createdAt(sort: Desc)])
  @@index([deletedAt, createdAt(sort: Desc)])
  @@index([authorId, createdAt(sort: Desc)])
  @@index([isPinned, createdAt(sort: Desc)])
  @@index([search_vector], type: Gin)
  @@map("activities")
}

model ActivityTagCandidate {
  id                 String    @id @default(uuid())
  name               String
  slug               String    @unique
  occurrences        Int       @default(1)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @default(now()) @updatedAt
  lastSeenAt         DateTime  @default(now())
  lastSeenActivityId String?
  activity           Activity? @relation(fields: [lastSeenActivityId], references: [id], onUpdate: NoAction, map: "activity_tag_candidates_last_seen_activity_id_fkey")

  @@index([lastSeenAt(sort: Desc)], map: "activity_tag_candidates_last_seen_idx")
  @@map("activity_tag_candidates")
}

model ActivityTag {
  activityId String
  tagId      String
  createdAt  DateTime @default(now())
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([activityId, tagId])
  @@index([activityId])
  @@index([tagId])
  @@map("activity_tags")
}

model Bookmark {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  userId    String
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("bookmarks")
}

/// 评论模型
/// 数据库约束: comments_target_xor_check - postId 和 activityId 互斥（最多一个非空）
model Comment {
  id            String         @id @default(uuid())
  content       String
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  authorId      String
  postId        String?        /// 与 activityId 互斥（数据库 CHECK 约束）
  activityId    String?        /// 与 postId 互斥（数据库 CHECK 约束）
  parentId      String?
  deletedAt     DateTime?      @db.Timestamp(6)
  activity      Activity?      @relation(fields: [activityId], references: [id], onDelete: Cascade)
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent        Comment?       @relation("commentsTocomments", fields: [parentId], references: [id], onDelete: NoAction)
  replies       Comment[]      @relation("commentsTocomments")
  post          Post?          @relation(fields: [postId], references: [id], onDelete: Cascade)
  notifications Notification[] @relation("NotificationComment")

  @@index([activityId])
  @@index([authorId])
  @@index([createdAt(sort: Desc)])
  @@index([deletedAt])
  @@index([parentId])
  @@index([postId])
  @@index([activityId, parentId, createdAt(sort: Desc), id(sort: Desc)])
  @@index([parentId, createdAt, id], map: "comments_parentId_createdAt_id_asc_idx")
  @@index([postId, parentId, createdAt(sort: Desc), id(sort: Desc)])
  @@map("comments")
}

model Follow {
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    User     @relation("follows_followerIdTousers", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("follows_followingIdTousers", fields: [followingId], references: [id], onDelete: Cascade)

  @@id([followerId, followingId])
  @@index([followerId, createdAt])
  @@index([followingId, createdAt])
  @@map("follows")
}

/// 点赞模型
/// 数据库约束: likes_target_xor_check - postId 和 activityId 互斥（最多一个非空）
model Like {
  id         String    @id @default(uuid())
  createdAt  DateTime  @default(now())
  authorId   String
  postId     String?   /// 与 activityId 互斥（数据库 CHECK 约束）
  activityId String?   /// 与 postId 互斥（数据库 CHECK 约束）
  activity   Activity? @relation(fields: [activityId], references: [id], onDelete: Cascade)
  author     User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  post       Post?     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([authorId, activityId])
  @@unique([authorId, postId])
  @@index([authorId])
  @@map("likes")
}

model PostTag {
  postId    String
  tagId     String
  createdAt DateTime @default(now())
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@map("post_tags")
}

model Post {
  id                   String                   @id @default(uuid())
  slug                 String                   @unique
  title                String
  content              String
  excerpt              String?
  published            Boolean                  @default(false)
  isPinned             Boolean                  @default(false)
  canonicalUrl         String?
  seoTitle             String?
  seoDescription       String?
  viewCount            Int                      @default(0)
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  publishedAt          DateTime?
  authorId             String
  seriesId             String?
  coverImage           String?
  titleTokens          String?
  excerptTokens        String?
  seoDescriptionTokens String?
  contentTokens        String?
  search_vector        Unsupported("tsvector")? @default(dbgenerated("(((setweight(to_tsvector('simple'::regconfig, COALESCE(\"titleTokens\", ''::text)), 'A'::\"char\") || setweight(to_tsvector('simple'::regconfig, COALESCE(\"excerptTokens\", ''::text)), 'B'::\"char\")) || setweight(to_tsvector('simple'::regconfig, COALESCE(\"seoDescriptionTokens\", ''::text)), 'B'::\"char\")) || setweight(to_tsvector('simple'::regconfig, COALESCE(\"contentTokens\", ''::text)), 'C'::\"char\"))"))
  bookmarks            Bookmark[]
  comments             Comment[]
  likes                Like[]
  notifications        Notification[]           @relation("NotificationPost")
  emailQueue           EmailQueue[]
  tags                 PostTag[]
  author               User                     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  series               Series?                  @relation(fields: [seriesId], references: [id])

  @@index([authorId])
  @@index([published, publishedAt(sort: Desc)])
  @@index([seriesId])
  @@index([createdAt(sort: Desc), id(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@index([isPinned])
  @@index([published, createdAt(sort: Desc)])
  @@index([search_vector], type: Gin)
  @@index([viewCount(sort: Desc)])
  @@map("posts")
}

model Series {
  id          String   @id
  title       String
  slug        String   @unique
  description String?
  coverUrl    String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  authorId    String
  posts       Post[]
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@map("series")
}

model Tag {
  id                String                   @id @default(uuid())
  name              String                   @unique
  slug              String                   @unique
  description       String?
  color             String?
  postsCount        Int                      @default(0)
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  activitiesCount   Int                      @default(0)
  nameTokens        String?
  descriptionTokens String?
  search_vector     Unsupported("tsvector")? @default(dbgenerated("(setweight(to_tsvector('simple'::regconfig, COALESCE(\"nameTokens\", ''::text)), 'A'::\"char\") || setweight(to_tsvector('simple'::regconfig, COALESCE(\"descriptionTokens\", ''::text)), 'B'::\"char\"))"))
  activities        ActivityTag[]
  posts             PostTag[]

  @@index([postsCount(sort: Desc)])
  @@index([search_vector], type: Gin)
  @@map("tags")
}

model User {
  id                      String                   @id @default(uuid())
  email                   String                   @unique
  name                    String?
  avatarUrl               String?
  coverImage              String?
  bio                     String?
  socialLinks             Json?
  role                    Role                     @default(USER)
  status                  UserStatus               @default(ACTIVE)
  passwordHash            String?
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  lastLoginAt             DateTime?
  nameTokens              String?
  bioTokens               String?
  search_vector           Unsupported("tsvector")? @default(dbgenerated("((setweight(to_tsvector('simple'::regconfig, COALESCE(\"nameTokens\", ''::text)), 'A'::\"char\") || setweight(to_tsvector('simple'::regconfig, regexp_replace(COALESCE(email, ''::text), '[^a-zA-Z0-9]+'::text, ' '::text, 'g'::text)), 'B'::\"char\")) || setweight(to_tsvector('simple'::regconfig, COALESCE(\"bioTokens\", ''::text)), 'C'::\"char\"))"))
  location                String?
  notificationPreferences Json                     @default("{}")
  phone                   String?
  privacySettings         Json                     @default("{}")
  activities              Activity[]
  bookmarks               Bookmark[]
  comments                Comment[]
  following               Follow[]                 @relation("follows_followerIdTousers")
  followers               Follow[]                 @relation("follows_followingIdTousers")
  likes                   Like[]
  notificationsSent       Notification[]           @relation("NotificationActor")
  notificationsReceived   Notification[]           @relation("NotificationRecipient")
  notificationsFollowed   Notification[]           @relation("NotificationFollower")
  performanceMetrics      PerformanceMetric[]
  posts                   Post[]
  series                  Series[]
  systemSettingsUpdated   SystemSetting[]          @relation("SystemSettingUpdatedBy")
  emailSubscriptions      EmailSubscriber[]

  @@index([bio(ops: raw("gin_trgm_ops"))], map: "idx_users_bio_trgm", type: Gin)
  @@index([name(ops: raw("gin_trgm_ops"))], map: "idx_users_name_trgm", type: Gin)
  @@index([email(ops: raw("gin_trgm_ops"))], map: "users_email_trgm_idx", type: Gin)
  @@index([search_vector], type: Gin)
  @@map("users")
}

model Notification {
  /// DB CHECK: exactly one of postId/activityId/followerId is non-null.
  id          String           @id @default(uuid())
  recipientId String
  actorId     String
  type        NotificationType
  readAt      DateTime?
  createdAt   DateTime         @default(now())
  postId      String?
  commentId   String?
  activityId  String?
  followerId  String?
  actor       User             @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)
  comment     Comment?         @relation("NotificationComment", fields: [commentId], references: [id])
  post        Post?            @relation("NotificationPost", fields: [postId], references: [id])
  activity    Activity?        @relation(fields: [activityId], references: [id])
  follower    User?            @relation("NotificationFollower", fields: [followerId], references: [id], onDelete: SetNull)
  recipient   User             @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  emailQueue  EmailQueue[]

  @@index([recipientId, readAt])
  @@index([followerId])
  @@map("notifications")
}

model EmailSubscriber {
  id                   String                    @id @default(uuid())
  email                String                    @unique
  userId               String?
  status               EmailSubscriptionStatus   @default(PENDING)
  verifyTokenHash      String?                   @unique
  verifyExpiresAt      DateTime?
  unsubscribeTokenHash String                    @unique
  verifiedAt           DateTime?
  lastDigestAt         DateTime?
  preferences          Json                      @default("{}")
  source               String?
  createdAt            DateTime                  @default(now())
  updatedAt            DateTime                  @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  emailQueue EmailQueue[]

  @@index([email])
  @@index([status])
  @@map("email_subscribers")
}

model EmailQueue {
  id             String           @id @default(uuid())
  subscriberId   String?
  type           NotificationType
  payload        Json
  scheduledAt    DateTime         @default(now())
  status         EmailQueueStatus @default(PENDING)
  attempts       Int              @default(0)
  lastError      String?
  sentAt         DateTime?
  notificationId String?
  postId         String?
  createdAt      DateTime         @default(now())

  subscriber   EmailSubscriber? @relation(fields: [subscriberId], references: [id], onDelete: SetNull)
  notification Notification?    @relation(fields: [notificationId], references: [id], onDelete: SetNull)
  post         Post?            @relation(fields: [postId], references: [id], onDelete: SetNull)

  @@index([status, scheduledAt])
  @@index([type])
  @@map("email_queue")
}

model PerformanceMetric {
  id        String     @id @default(cuid())
  type      MetricType
  value     Float
  unit      String
  timestamp DateTime   @default(now())
  context   Json?
  tags      String[]   @default([])
  requestId String?
  userId    String?
  user      User?      @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([type, timestamp(sort: Desc)])
  @@index([tags])
  @@index([userId])
  @@map("performance_metrics")
}

model SystemSetting {
  key         String   @id
  value       Json
  category    String?
  description String?
  updatedById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy   User?    @relation(name: "SystemSettingUpdatedBy", fields: [updatedById], references: [id])

  @@map("system_settings")
}

enum Role {
  USER
  ADMIN
}

enum UserStatus {
  ACTIVE
  BANNED
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  SYSTEM
  NEW_POST
}

enum EmailSubscriptionStatus {
  PENDING
  VERIFIED
  UNSUBSCRIBED
  BOUNCED
}

enum EmailQueueStatus {
  PENDING
  SENDING
  SENT
  FAILED
}

enum MetricType {
  api_response
  db_query
  cache_hit
  external_api
  auth_login
  auth_session
  permission_check
}
```

---

### **4.0 核心流程设计**

#### **4.1 认证与授权**

授权检查是所有 Server Action 的第一步，基于 `Role` 和 `Status` 进行。

- **互动权限 (评论、点赞、发动态、关注)**: 检查用户是否**已登录**且 `status` 为
  `ACTIVE`。
- **博客管理权限 (发文、删改)**: 检查用户是否**已登录**且 `role` 为 `ADMIN`。
- **用户管理权限 (改角色、改状态)**: 检查操作者是否**已登录**且 `role` 为
  `ADMIN`。

#### **4.2 文章归档实现**

- **数据基础**: `Post` 模型中的 `createdAt`
  字段是实现此功能的唯一数据来源，无需修改模型。
- **后端查询**: 需要创建一个 Server
  Action，使用 Prisma 的聚合（`groupBy`）功能，按年份和月份对 `Post`
  进行分组并计数。
- **前端路由**: 创建一个新的动态路由页面，如
  `app/archive/[year]/[month]/page.tsx`。

#### **4.3 动态交互实现建议**

前端应采用**乐观更新 (Optimistic UI)** 策略来实现流畅的点赞和评论体验。

---

### **5.0 项目实施规划**

#### 5.1 推荐项目目录结构

```
/jikns_blog
├── /app                  # Next.js App Router 核心
├── /components           # 全局共享的 React 组件
├── /lib                  # 核心业务逻辑与工具库
│   ├── /actions          # Server Actions (业务入口，Zod校验，权限检查)
│   ├── /services         # 业务逻辑层 (处理复杂业务规则，调用Repo)
│   ├── /repos            # 数据访问层 (直接操作Prisma，封装DB查询)
│   ├── /dto              # 数据传输对象 (定义API返回的数据结构)
│   ├── /permissions      # 权限控制逻辑 (RBAC & ABAC实现)
│   ├── /validation       # Zod Schema定义 (输入验证)
│   ├── /interactions     # 统一交互逻辑 (点赞/评论/收藏的多态处理)
│   └── ...               # 其他工具 (utils, hooks等)
├── /prisma               # Prisma schema
├── /supabase             # 由 Supabase CLI 管理
│   ├── /migrations       # 数据库迁移的 SQL 文件
│   └── config.toml       # 本地 Supabase 环境配置
└── ...
```

#### **5.2 测试策略**

- **单元测试 (Unit Tests)**: 使用 Vitest 测试独立的 Server
  Actions 和业务逻辑函数。
- **组件测试 (Component Tests)**: 使用 Vitest 和 React Testing
  Library 测试复杂的交互式客户端组件。
- **端到端测试 (E2E
  Tests)**: （推荐）使用 Playwright 或 Cypress 测试核心用户流程。

#### **5.3 部署与运维 (DevOps)**

采用与数据库迁移深度集成的自动化 CI/CD 流程：

1.  **触发**: 代码合并到 `main` 分支，触发 Vercel 的部署流程。
2.  **数据库迁移**: 在 Vercel 构建开始前的 `pre-build`
    步骤中，执行脚本，将 Git 仓库中新的迁移安全地应用到生产数据库。
3.  **应用部署**: 数据库迁移成功后，Vercel 继续构建和部署 Next.js 应用。

#### **5.4 建议开发路线图**

- **第一阶段: 基建与用户系统**: 初始化技术栈，创建 v4.0 数据模型，完成双重认证系统。
- **第二阶段: 核心模块**:
  - **博客模块**: 实现文章 CRUD、文章系列、置顶、Canonical
    URL、文章归档、评论、点赞等功能。
  - **动态模块**: 实现动态的发布、置顶、评论、点赞、关注用户、双信息流（推荐/关注）等功能。
  - **用户管理模块**: 实现用户列表、角色修改、状态变更的后台管理界面。
- **第三阶段: 优化与完善**: 全面进行 SEO 优化，完善测试覆盖，打磨交互细节。
- **后续迭代规划**: **通知系统 (@提及)**、**邮件订阅 (Newsletter)**。

---

### **6.0 数据分析与可视化策略**

采用应用内数据 + Vercel Analytics 的分层策略。

---

### **7.0 架构分析与未来展望**

本章节旨在对当前 v4.0 架构进行客观评估，指出其优势、潜在瓶颈和未来的演进方向。

#### **7.1 可行性评估 (Feasibility)**

当前架构是**高度可行**的。我们选择的 **Next.js + Supabase + Prisma**
技术栈是成熟的现代化解决方案，足以支撑项目从零到一的全部功能。我们采用的通用化数据模型、Server
Actions 等设计模式，在保证功能的同时，也确保了良好的开发体验。

#### **7.2 潜在性能瓶颈 (Potential Performance Bottlenecks)**

为了追求开发效率，当前架构在以下几个方面存在未来可能需要优化的性能瓶颈：

1.  **动态信息流生成 (Feed
    Generation)**: 当前的“读时拉取”模式，在用户关注数增多后，查询性能会下降。这是所有社交应用需要面对的首要性能挑战。
2.  **实时计数 (Real-time
    Counting)**: 在列表页对每项内容都实时计算点赞/评论数（`_count`），在高并发下会给数据库带来压力。
3.  **缺少专用缓存层 (Lack of Caching
    Layer)**: 对热门文章、标签云等高频访问但低频变化的数据，反复查询数据库是种资源浪费。

#### **7.3 长期可升级性与优化路径 (Long-term Scalability & Optimization Paths)**

当前架构的优势在于，为上述所有瓶颈都预留了清晰、平滑的升级路径，我们无需在项目初期就进行过度设计。

1.  **信息流优化 ->
    “写时扇出”**: 当性能需要时，我们可以引入后台任务队列，将信息流的生成模式从“读时拉取”重构为“写时扇出”，将计算压力分摊到写操作上。
2.  **计数优化 -> “缓存计数器”**: 当计数查询成为瓶颈，我们可以为 `Post`
    等模型重新引入 `likesCount`
    等字段，在点赞/评论时通过事务更新此计数值，将读操作变为O(1)级别的查询。
3.  **缓存优化 -> “引入 Redis”**: 当数据库压力增大时，我们可以随时在架构中加入
    **Redis** 作为缓存层，用于缓存高频查询的结果，而无需改动核心业务逻辑。
4.  **服务迁移**: 当 Supabase 无法满足最终的性能需求时，由于其开放性（标准 Postgres），我们可以平滑地将数据迁移至更高规格的数据库平台，并逐步自研替换其认证、存储等服务。

**最终结论**: 当前架构是一个完美的起点，它让我们能快速前进，同时对未来的技术挑战和演进方向了然于胸。

---

### **8.0 本地开发环境配置**

#### **8.1 Supabase CLI 本地开发环境**

项目采用官方 **Supabase CLI**
作为主要的本地开发环境，提供与生产环境完全一致的功能和配置。

**服务架构**:

- **PostgreSQL 15**: 主数据库服务 (端口: 54322)
- **Supabase Auth (GoTrue)**: 认证服务 (端口: 9999)
- **PostgREST**: REST API 服务 (端口: 3000)
- **Supabase Storage**: 存储服务 (端口: 8000)
- **Kong Gateway**: API 网关和路由 (端口: 54321)
- **Supabase Studio**: Web 管理界面 (端口: 54323)

**核心优势**:

1. **官方支持**: Supabase CLI 是官方维护的本地开发解决方案
2. **功能完整**: 包含完整的 Supabase 功能栈，包括 Studio 管理界面
3. **配置同步**: 本地配置可直接同步到云端生产环境
4. **迁移管理**: 内置完善的数据库迁移版本控制系统
5. **零配置启动**: 一条命令启动完整的 Supabase 本地环境

#### **8.2 开发工作流**

**环境安装**:

```bash
# 安装 Supabase CLI
npm install -g @supabase/cli

# 验证安装
supabase --version
```

**项目初始化**:

```bash
# 初始化 Supabase 项目（首次）
supabase init

# 启动本地 Supabase 服务
supabase start
```

**开发流程**:

1. 启动 Supabase 本地服务 (`supabase start`)
2. 修改 Prisma Schema (`prisma/schema.prisma`)
3. 推送 Schema 到本地数据库 (`npx prisma db push`)
4. 生成迁移文件 (`supabase db diff -f migration_name`)
5. 启动 Next.js 开发服务器 (`pnpm dev`)

**环境管理**:

```bash
# 启动本地服务
supabase start

# 查看服务状态
supabase status

# 停止本地服务
supabase stop

# 重置本地环境（慎用）
supabase db reset
```
